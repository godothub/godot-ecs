## 1. Getting Started & Basics (Direct Mode)

### 1. Introduction & Environment Setup

#### 1.1 Why choose this framework?

This framework is designed specifically for Godot 4 (>=4.5) and provides two development paradigms:

1. **Direct Mode (`ECSSystem`)**: Similar to Godot's `Node` logic, supports a full lifecycle (Enter/Exit/Update), and allows systems to hold state. Suitable for UI, game flow, input control logic, etc.
2. **Scheduled Mode (`ECSParallel`)**: Pure ECS paradigm, stateless, supports multi-threaded parallelism and dependency analysis. Suitable for high-performance computing, physics simulation, and massive entity updates.

**This section of the documentation will focus on "Direct Mode" to help you quickly build a world and get your game running.**

#### 1.2 Installation

Simply copy the framework source folders (usually named `GodotECS` and `GodotUtils`) into your project's `res://` directory.

Alternatively, search for Godot ECS in the Asset Library inside the Godot editor and download it to your local project.

---

### 2. The World

`ECSWorld` is the container for all entities, components, and systems.

#### 2.1 Initialize World

Usually, you initialize the world in Godot's main scene script (e.g., `Main.gd`).

```gdscript
# Main.gd
extends Node

var _world: ECSWorld

func _ready() -> void:
    # 1. Create the world, give it a name for debugging
    _world = ECSWorld.new("GameWorld")

    # Enable debug printing (optional)
    _world.debug_print = true

func _process(delta: float) -> void:
    # 2. Drive world update
    # This triggers the _on_update method of all ECSSystems
    _world.update(delta)

func _exit_tree() -> void:
    # 3. Clean up resources
    _world.clear()
```

#### 2.2 Define Components

Components are containers for data. The framework provides several basic types:

* **`ECSComponent`**: Basic component, requires custom properties.
* **`ECSDataComponent`**: Contains a generic `data` property, suitable for storing simple values.
* **`ECSViewComponent`**: Specifically used for binding Godot `Node`s.

**Example: Defining Health and Position Components**

```gdscript
# components.gd

# Method A: Inherit ECSDataComponent (Suitable for single value)
class CompHealth extends ECSDataComponent:
    pass # Uses built-in .data property to store health

# Method B: Inherit ECSComponent (Suitable for composite data)
class CompPos extends ECSComponent:
    var x: float = 0.0
    var y: float = 0.0

    func _init(px: float = 0, py: float = 0):
        x = px
        y = py

# Method C: Inherit ECSViewComponent (Binding Nodes)
class CompSprite extends ECSViewComponent:
    # The .view property inherited from base class will store the Node reference
    pass
```

#### 2.3 Create Entities

An entity is just an ID; it is the carrier on which components are mounted.

```gdscript
# Inside _ready of Main.gd

# Create an entity
var entity = _world.create_entity()

# Add components
entity.add_component("Health", CompHealth.new(100))
entity.add_component("Position", CompPos.new(10, 20))

# Bind a Sprite node from the scene
var sprite_node = $Sprite2D
entity.add_component("View", CompSprite.new(sprite_node))

print("Created Entity ID:", entity.id())
```

---

### 3. Writing Systems (`ECSSystem`)

In Direct Mode, systems inherit from `ECSSystem`. Like traditional classes, they can have member variables (state) or process data by iterating like ECS systems.

#### 3.1 Create a Movement System

This system is responsible for reading `Position` components, updating data, and syncing it to `View` components (Sprite nodes).

```gdscript
# systems/sys_movement.gd
extends ECSSystem

# Internal System State - Only allowed in ECSSystem, not recommended for ECSParallel
var _speed: float = 50.0

# [Lifecycle] Called when system enters the world
func _on_enter(world: ECSWorld) -> void:
    print("Movement System Started")

# [Lifecycle] Called every frame (triggered by world.update(delta))
func _on_update(delta: float) -> void:
    # 1. Get all entities with Position and View components
    # Uses world().multi_view to leverage caching automatically
    var views = world().multi_view(["Position", "View"])

    for v in views:
        # Get component instances
        var pos = v["Position"] as CompPos
        var sprite = v["View"] as CompSprite

        # Logic: Simple move to the right
        pos.x += _speed * delta

        # Sync: Update Godot Node position
        if is_instance_valid(sprite.view):
            sprite.view.position = Vector2(pos.x, pos.y)

# [Lifecycle] Called when system exits/is destroyed
func _on_exit(world: ECSWorld) -> void:
    print("Movement System Closed")
```

#### 3.2 Register System

Systems must be registered to the World to run.

Note: The update order of systems (execution order of `_on_update`) is determined by the order in which they are registered to the World.

```gdscript
# Main.gd

func _ready() -> void:
    _world = ECSWorld.new("GameWorld")

    # ... (Component initialization) ...

    # Register system
    # Arg 1: System name (for indexing)
    # Arg 2: System instance
    _world.add_system("MovementSystem", SysMovement.new())
```

---

### 4. Event Driven Programming

`ECSSystem` can easily listen for and send events, which is very useful for handling game logic (such as "Player Died", "Score Added").

#### 4.1 Send Events

You can send events from anywhere (inside entity methods, inside system logic).

```gdscript
# In some damage logic
func apply_damage(entity_id: int, amount: int):
    # ... Deduct HP logic ...
    if hp <= 0:
        # Method 1: Notify via World directly
        _world.notify("entity_died", entity_id)

        # Method 2: Notify via Entity wrapper (if you hold the Entity object)
        # entity.notify("entity_died", entity_id)
```

#### 4.2 Listen to Events in Systems

Use `_on_enter` to bind events and `_on_exit` to unbind them (although the framework automatically cleans up when the System is destroyed, explicit unbinding is a good habit).

```gdscript
# systems/sys_game_manager.gd
extends ECSSystem

func _on_enter(world: ECSWorld) -> void:
    # Listen for "entity_died" event
    world.add_callable("entity_died", _on_entity_died)

func _on_exit(world: ECSWorld) -> void:
    world.remove_callable("entity_died", _on_entity_died)

# Event callback
func _on_entity_died(event: GameEvent) -> void:
    var dead_entity_id = event.data
    print("Detected entity death: ", dead_entity_id)

    # Execute game logic, e.g., add score or remove entity
    world().remove_entity(dead_entity_id)
```

---

### Part 1 Summary: Direct Mode Workflow

1. **Create World**: `ECSWorld.new()`.
2. **Define Component**: Inherit `ECSComponent` or `ECSDataComponent`.
3. **Create Entity**: `world.create_entity()` and `add_component()`.
4. **Define System**: Inherit `ECSSystem`.
   * Override `_on_update(delta)` to handle per-frame logic.
   * Use `world().view()` or `world().multi_view()` to get data.
   * Use `_on_enter` to listen for events.
5. **Drive World**: Call `world.update(delta)` in Godot's `_process`.

This mode does not require configuring complex scheduler dependencies. Writing it feels like writing a Manager class in Godot, but the underlying data is fully ECS-based.

---

**Next Part:** [2. General Data Operations](./2.General_Data_Operations.md)
