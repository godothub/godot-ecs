## 2. General Data Operations & State Modification

Whether you use the single-threaded `ECSSystem` or the multi-threaded `ECSParallel`, **querying** and **modifying** data are the core operations.

### 1. Querying Mechanism

In system `_on_update (ECSSystem)` or `thread_function (ECSParallel)`, we need to find specific sets of entities to process. The framework provides three levels of querying.

#### 1.1 Basic View (`view`)

The simplest way is to retrieve a list of all component instances for a specific single component.

* **Use Case**: Only need to process one type of data, e.g., calculating total health of all entities.
* **Return Value**: Array of component instances `Array[ECSComponent]`.

```gdscript
# Get all Health components
var healths = world().view("Health")
for hp in healths:
    print(hp.data)
```

#### 1.2 Multi-View (`multi_view`)

Retrieve entities that possess **multiple specified components simultaneously**. This is the most common operation in ECS.

* **Use Case**: Movement system (needs Position + Velocity), Render system (needs Position + Sprite).
* **Caching Mechanism**: The framework uses `QueryCache` internally. It builds a cache upon the first request for `["A", "B"]`. Subsequent frame calls have nearly zero overhead. Adding/removing components automatically updates the cache.
* **Return Value**: Dictionary Array `Array[Dictionary]`. The dictionary contains the `entity` reference and the requested components.

```gdscript
# Get entities with both Position and Velocity
var results = world().multi_view(["Position", "Velocity"])

for res in results:
    var entity = res["entity"]       # Get entity reference
    var pos = res["Position"]        # Get component instance
    var vel = res["Velocity"]

    # Business logic
    pos.x += vel.x * delta
```

#### 1.3 Advanced Querier (`Querier`)

When simple "AND" logic is not enough, you can use the builder-pattern Querier.

* **Use Case**: Complex filtering logic, e.g., "Has A but NOT B", or "Has A OR B".
* **Construction**: Get a new querier instance via `world().query()`.

```gdscript
# Find: Entities with Health component, NO Debuff component, and health < 50
var dying_entities = world().query() \
    .with(["Health"]) \
    .without(["Debuff"]) \
    .filter(func(data): return data["Health"].data < 50) \
    .exec()

# Note: Querier calculates dynamically on every exec, performance is slightly lower than multi_view cache reading.
# In high-frequency Hot Paths, prefer using multi_view.
```

---

### 2. Modifying World State: Immediate vs Command Buffer

In ECS, "modifying component properties" (like `pos.x += 1`) is usually safe, but "modifying world structure" (like creating entities, deleting components) is very sensitive.

#### 2.1 Why are there two ways to modify?

| Method             | **Immediate Modification**                                                          | **Deferred Commands**                                                                                      |
|:------------------ |:----------------------------------------------------------------------------------- |:---------------------------------------------------------------------------------------------------------- |
| **Operation API**  | `world.create_entity()`, `e.destroy()`                                              | `cmds.spawn()`, `cmds.entity(id).destroy()`                                                                |
| **Effective Time** | **Immediate**. Changes are visible in the next line of code.                        | **Deferred**. Executed uniformly at the end of the frame (or on manual flush).                             |
| **Thread Safety**  | **❌ Unsafe**. Will cause crashes or race conditions in multi-threaded environments. | **✅ Safe**. Each thread writes to an independent Buffer, finally merged and executed on the main thread.   |
| **Use Case**       | Single-threaded systems (`ECSSystem`); Main thread logic; Initialization phase.     | Multi-threaded systems (`ECSParallel`); Scenarios needing to avoid modifying collections during iteration. |

#### 2.2 Scenario A: Immediate Modification in Single Thread (`ECSSystem`)

In `_on_update` of `ECSSystem`, since it runs on the main thread, you can call World APIs directly.

**⚠️ The only trap: Modification during iteration**
Even in a single thread, if you are iterating over a list (like the array returned by `view`), deleting an entity at this moment will cause iterator invalidation or logic errors.

```gdscript
# [Incorrect Example]
var list = world().view("Health")
for hp in list:
    if hp.data <= 0:
        # Dangerous! Deleting an element while iterating the list may cause skipping the next element or errors
        hp.entity().destroy() 

# [Correct Method 1]: Iterate in reverse (More verbose in GDScript)
# [Correct Method 2]: Collect IDs to delete, then delete uniformly after iteration
var to_delete = []
for hp in list:
    if hp.data <= 0:
        to_delete.append(hp.entity().id())

for id in to_delete:
    world().remove_entity(id)
```

#### 2.3 Scenario B: Command Buffer in Multi-Thread (`ECSParallel`)

When working in `ECSParallel` (introduced in the next chapter), systems may run on background threads. At this time, it is **strictly forbidden** to call `world.create_entity()` or `add_component()` directly.

The framework provides `Commands` to solve this problem.

**Note:** `Commands` is an internal class reference. In `ECSParallel` callback methods, the framework passes this object to you.

**API Usage Example:**

```gdscript
# Assume this is inside ECSParallel._view_components method
# cmds is the Commands instance passed by the framework

# 1. Destroy entity
cmds.entity(entity_id).destroy()

# 2. Spawn new entity and add components (Fluent API)
cmds.spawn() \
    .add_component("Health", CompHealth.new(100)) \
    .add_component("Position", CompPos.new(0, 0))

# 3. Add/Remove components for existing entity
cmds.entity(entity_id) \
    .add_component("Buff", CompBuff.new()) \
    .remove_component("Debuff")

# 4. Send deferred event (Also for thread safety)
cmds.notify("enemy_spawned", 1)
```

**Principle Explanation:**
All operations are encoded as simple instructions (OpCodes) and stored in an array. When the scheduler (`Scheduler`) finishes all parallel tasks, it executes these instructions uniformly on the main thread (`flush`). This means:

* Entities you `spawn()` in a thread are **invisible** to subsequent systems in the current frame.
* They will truly appear in the World before the start of the next frame.

---

### Part 2 Summary

* **Query Data**:
  * Use `view` for simple cases.
  * Use `multi_view` for common combinations (fast, cached).
  * Use `query()...exec()` for complex filtering.
* **Modify Data**:
  * **In `ECSSystem` (Single-threaded)**: Can call `world.remove_entity` APIs directly, but be careful with collection modification safety during iteration.
  * **In `ECSParallel` (Multi-threaded)**: **Must** use the passed `cmds` (Commands) object for deferred operations.

---

**Next Part:** [3. Scheduled Mode](./3.Advanced_and_Parallel.md)
