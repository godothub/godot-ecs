## 3. Advanced & Parallel (Scheduled Mode)

In simple games, using `ECSSystem` to manually control update order is sufficient. However, when your game involves complex physics simulations, hundreds or thousands of AI units, or you need strict control over system execution order (e.g., Input -> Move -> Physics -> Render), **Scheduler Mode** is the best choice.

### 1. Why do we need a Scheduler?

The scheduler (`ECSScheduler`) is an automated pipeline that solves three key problems:

1. **Dependency Management**: Automatically parses `before/after` relationships between systems, builds a Directed Acyclic Graph (DAG), and ensures correct logic execution order.
2. **Concurrent Execution**: Analyzes component read/write permissions, automatically identifies non-conflicting systems, and puts them into `WorkerThreadPool` for parallel execution.
3. **Command Synchronization**: Automatically merges and executes `Commands` from all systems at the end of the frame (or between batches) without manual intervention.

### 2. Writing Parallel Systems (`ECSParallel`)

In Scheduled Mode, we no longer use `ECSSystem`, but inherit from `ECSParallel`.

**Key Rules:**

* ❌ **Stateless**: Try not to store state variables (like timers) inside the system class. State should be stored in Singleton components or Resources.
* ❌ **No Lifecycle**: There is no `_on_enter` or `_on_exit`. It only focuses on data transformation.
* ✅ **Permission Declaration**: You must explicitly tell the framework what you want to read and what you want to write.

#### 2.1 Example: Writing a Simple Health Regeneration System

```gdscript
# systems/sys_regen.gd
extends ECSParallel

func _init():
    # Must give the system a name for scheduler dependency reference
    super._init("RegenSystem")

# [Core 1] Declare Permissions
# Tell the scheduler: I want to read/write "Health" component, read-only "RegenRate" component
func _list_components() -> Dictionary:
    return {
        "Health": ECSParallel.READ_WRITE, # May modify health
        "RegenRate": ECSParallel.READ_ONLY # Only read regeneration rate
    }

# [Core 2] Enable Multi-threading
# Return true means this system can split tasks internally for parallel processing
func _parallel() -> bool:
    return true 

# [Core 3] Business Logic
# The framework automatically iterates over entities matching the _list_components combination
# Arg 1: view (Dictionary containing components of current entity)
# Arg 2: cmds (Thread-safe command buffer, ECSParallel.Commands type)
func _view_components(view: Dictionary, cmds: ECSParallel.Commands) -> void:
    var hp = view["Health"] as CompHealth
    var rate = view["RegenRate"] as CompRegen

    # Simple numeric logic
    if hp.data < hp.max_value:
        hp.data += rate.value * delta # Note: delta is a member variable, injected by framework

        # If health is full, use cmds to remove regeneration component (deferred effect)
        if hp.data >= hp.max_value:
            hp.data = hp.max_value
            cmds.entity(view.entity.id()).remove_component("RegenRate")
```

#### 2.2 Understanding `_parallel()` Switch

* `return true`: The framework will split the matching entity list into multiple chunks and distribute them to multiple Worker threads to execute `_view_components` simultaneously. Suitable for handling a large number of entities (e.g., 1000+ units).
* `return false`: The entire system logic runs in a single thread (although the system itself may run in parallel with other systems). Suitable for systems with fewer entities or simple logic.

---

### 3. Building & Running the Scheduler

Once we have systems, we need to assemble them.

#### 3.1 Create Scheduler

Usually done during main scene initialization.

```gdscript
# Main.gd
var _scheduler: ECSScheduler

func _ready() -> void:
    _world = ECSWorld.new("GameWorld")
    _scheduler = _world.create_scheduler("MainLoop")

    # Instantiate systems
    var sys_input = SysInput.new()
    var sys_move = SysMovement.new()
    var sys_physics = SysPhysics.new()
    var sys_render = SysRender.new()

    # [Key] Define Dependencies
    # Movement must be after Input
    sys_move.after(["InputSystem"])
    # Physics must be after Movement
    sys_physics.after(["MovementSystem"]) 
    # Render must be after Physics
    sys_render.after(["PhysicsSystem"])

    # Add to scheduler
    _scheduler.add_systems([
        sys_input, 
        sys_move, 
        sys_physics, 
        sys_render
    ])

    # [Build] Parse dependency graph, analyze read/write conflicts, generate execution plan
    _scheduler.build()

func _process(delta: float) -> void:
    # Drive scheduler
    _scheduler.run(delta)
```

#### 3.2 Conflict Detection & Automatic Batching

Suppose you have the following two systems:

1. `SysA`: Writes `Position`
2. `SysB`: Reads `Position`

If no `.after()` / `.before()` dependency is set:

* **Traditional ECS**: May cause race conditions or indeterminate results.
* **This Framework**: During build, the scheduler detects a **resource conflict** between `SysA` (Write) and `SysB` (Read) on the `Position` component. It automatically places them in different execution batches to run serially, ensuring safety.

Suppose you have:

1. `SysMove`: Writes `Position`

2. `SysDamage`: Writes `Health` (Unrelated to Position)
* **This Framework**: The scheduler finds no resource conflict between the two and arranges them in the same batch, utilizing two CPU cores to **execute simultaneously**.

---

### 4. Advanced Scheduling Techniques

#### 4.1 System Grouping (`in_set`)

You can assign an integer Group ID to a system. During topological sorting, the scheduler tends to execute systems with smaller Group IDs first (provided dependencies are met). This helps with logic layering.

```gdscript
enum { PHASE_INPUT, PHASE_GAMEPLAY, PHASE_RENDER }

sys_input.in_set(PHASE_INPUT)
sys_move.in_set(PHASE_GAMEPLAY)
```

#### 4.2 Dynamic System Switching

The scheduler is a static execution graph after building. If you need to temporarily disable a system, the simplest way currently is to add a check inside the system, or simply not call `scheduler.run()`.
*Note: `ECSWorld.set_system_update` is only effective for `ECSSystem`, not for `ECSParallel` inside the scheduler pipeline.*

---

### Part 3 Summary

Scheduled Mode is the key to high-performance development:

1. **Define System**: Inherit `ECSParallel`, specify `_list_components` read/write permissions.
2. **Handle Logic**: Write logic in `_view_components`, use `cmds` to modify structure.
3. **Configure Dependency**: Use `.after()`, `.before()` to weave the logic web.
4. **Build & Run**: `scheduler.build()` -> `scheduler.run()`.

In this way, you can confidently scale your game without worrying about complex update order maintenance or multi-threading crashes.

---

**Next Part:** [4. Ecosystem (Serialization, Debugging & Testing)](./4.Ecosystem.md)
