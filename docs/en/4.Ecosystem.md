## 4. Ecosystem (Serialization, Debugging & Testing)

### 1. Serialization System

Godot's native `var_to_bytes` can save simple data, but it falls short for an ECS world containing complex class instances and circular references. This framework provides a serialization scheme based on **Archives** and **UID Mapping**, supporting data version upgrades.

#### 1.1 Making Components Serializable

To make a component saveable, you need to override the `_on_pack` (serialize) and `_on_unpack` (deserialize) methods of the base class `ECSComponent`.

*(Note: `ECSDataComponent` implements serialization for its `data` property by default, no extra code needed)*

```gdscript
# components.gd
class CompPlayerStats extends ECSComponent:
    var level: int = 1
    var exp: int = 0

    # Write to archive
    func _on_pack(ar: Archive) -> void:
        ar.set_var("level", level)
        ar.set_var("exp", exp)

    # Read from archive
    func _on_unpack(ar: Archive) -> void:
        level = ar.get_var("level", 1) # Second argument is default value
        exp = ar.get_var("exp", 0)
```

#### 1.2 Data Version Control & Migration (Data Upgrading)

When the game updates, you might modify the component structure (e.g., changing `exp` to float, or adding new properties). Reading old saves directly might cause crashes. The framework supports smooth migration.

```gdscript
class CompPlayerStats extends ECSComponent:
    var level: int = 1
    var exp: float = 0.0 # [New Version Change] exp changed to float
    var title: String = "Novice" # [New Version Change] added title

    # Define the latest version number of the current component
    func _init():
        pass

    func _on_pack(ar: Archive) -> void:
        ar.version = 2 # Mark current data as version 2
        ar.set_var("level", level)
        ar.set_var("exp", exp)
        ar.set_var("title", title)

    func _on_unpack(ar: Archive) -> void:
        # This method only handles reading the latest version (v2)
        level = ar.get_var("level", 1)
        exp = ar.get_var("exp", 0.0)
        title = ar.get_var("title", "Novice")

    # [Key] Data conversion logic: Responsible for filling/converting old version data to new version
    func _on_convert(ar: Archive) -> void:
        match ar.version:
            0:
                # v0 to v1: Assume v1 introduced float exp
                var old_exp = ar.get_var("exp", 0)
                ar.set_var("exp", float(old_exp))
            1:
                # v1 to v2: v2 added title
                ar.set_var("title", "Novice")
        # The framework automatically increments ar.version + 1 and loops this method until the latest version is reached
```

#### 1.3 Registering Object Factory (`ObjectFactory`)

Since components are Godot script objects, deserialization needs to know "which data corresponds to which class". We need to register them with `ObjectFactory`. This is especially important for Inner Classes.

```gdscript
var factory = ObjectFactory.new()

# Register component class
factory.register(CompPlayerStats)
factory.register(CompHealth, [0]) # Provide default values here if constructor has required arguments

# If it is a global class, manual registration is usually not needed, the framework uses UID for lookup
```

#### 1.4 Saving & Loading World (`ECSWorldPacker`)

Once everything is ready, use `ECSWorldPacker` to save the entire ECS world with one click.

```gdscript
# Save Logic
func save_game(file_path: String) -> void:
    var packer = ECSWorldPacker.new(_world).with_factory(factory)
    var pack_data = packer.pack() # Returns DataPack object

    # Convert DataPack to byte stream and save to file
    var stream = ByteStream.new()
    stream.encode_var(pack_data.data())
    stream.write(file_path)

# Load Logic
func load_game(file_path: String) -> void:
    var stream = ByteStream.open(file_path)
    if stream:
        var raw_data = stream.decode_var()
        var pack_data = DataPack.new(raw_data)

        # Create world packer here, also set custom Object Factory
        var packer = ECSWorldPacker.new(_world).with_factory(factory)

        # unpack automatically clears current world and restores save state
        if packer.unpack(pack_data):
            print("Load game success!")
```

**⚠️ Special Note: Serialization of View Components**
`ECSViewComponent` stores references to Godot scene nodes. **Node references cannot be serialized**.
The usual practice is:

1. Do not save ViewComponent.
2. After reading the save, trigger an "Entity Loaded" event, and let a system generate Godot nodes and re-bind them to the restored entities.

---

### 2. Debugging & Testing

One downside of ECS is that data resides in code pools, making it hard to view intuitively like the Godot Scene Tree. The framework provides the following tools:

#### 2.1 Enable Debug Printing

Enable it during world initialization to see logs for entity creation, component addition/removal, and event triggering in the Godot console.

```gdscript
_world = ECSWorld.new("GameWorld")
_world.debug_print = true # Print detailed logs
```

#### 2.2 Using Debug Entity (`DebugEntity`)

If you inspect an `ECSEntity` in the Godot Debugger Inspector, by default you won't see what components it has attached (because components live in the World's pool).

Enabling `debug_entity` makes entities use the `DebugEntity` class, which maintains an internal `_components` dictionary, facilitating internal data inspection at breakpoints.

```gdscript
_world.debug_entity = true # All created entities will become DebugEntity instances
```

#### 2.3 Test Suite (`ECSTestSuite`)

The framework comes with `test_suite.gd`. If you modify the framework source code or suspect unexpected behavior, you can run it.
Also, **this file is the best living API textbook**, demonstrating standard usage of CRUD, complex Queries, Schedulers, and Serialization.

```gdscript
# Run tests in an empty scene
var test = ECSTestSuite.new()
test.run()
```

---

### Part 4 Summary

You have mastered all the advanced features needed to build a complete game with this framework:

* Use `Archive` for flexible component data serialization.
* Utilize `_on_convert` to solve save compatibility issues caused by version iteration.
* Use `ECSWorldPacker` for world snapshot backups.
* Use debugging tools to trace ECS black-box state.

---

**Next Part:** [API Reference](./5.API_Reference.md)
