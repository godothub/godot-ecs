## 1. 入门与基础 (直接模式 / Direct Mode)

### 1. 简介与环境配置

#### 1.1 为什么选择这个框架？

本框架专为 Godot 4 (>=4.5) 设计，提供了两种开发范式：

1. **直接模式 (`ECSSystem`)**：类似 Godot 的 `Node` 逻辑，支持完整的生命周期（Enter/Exit/Update），允许系统持有状态。适合处理 UI、游戏流程、输入控制等逻辑。
2. **调度模式 (`ECSParallel`)**：纯正的 ECS 范式，无状态，支持多线程并行和依赖分析。适合高性能计算、物理模拟和大规模实体更新。

**本部分文档将聚焦于“直接模式”，帮助你快速建立世界并让游戏跑起来。**

#### 1.2 安装

将框架源码文件夹（通常命名为 `GodotECS` 和 `GodotUtils`）复制到你的项目 `res://` 目录下即可。

或者直接在 godot 编辑器内部的资产库搜索 Godot ECS 并下载到本地工程。

---

### 2. 构建世界 (The World)

`ECSWorld` 是所有实体、组件和系统的容器。

#### 2.1 初始化世界

通常在 Godot 的主场景脚本（如 `Main.gd`）中初始化世界。

```gdscript
# Main.gd
extends Node

var _world: ECSWorld

func _ready() -> void:
    # 1. 创建世界，赋予一个调试用的名字
    _world = ECSWorld.new("GameWorld")

    # 开启调试打印 (可选)
    _world.debug_print = true

func _process(delta: float) -> void:
    # 2. 驱动世界更新
    # 这会触发所有 ECSSystem 的 _on_update 方法
    _world.update(delta)

func _exit_tree() -> void:
    # 3. 清理资源
    _world.clear()
```

#### 2.2 定义组件 (Components)

组件是数据的容器。框架提供了几种基础类型：

* **`ECSComponent`**: 基础组件，需自定义属性。
* **`ECSDataComponent`**: 包含一个泛型 `data` 属性，适合存简单数值。
* **`ECSViewComponent`**: 专门用于绑定 Godot 的 `Node`。

**示例：定义生命值和位置组件**

```gdscript
# components.gd

# 方式 A: 继承 ECSDataComponent (适合单数值)
class CompHealth extends ECSDataComponent:
    pass # 使用自带的 .data 属性存储血量

# 方式 B: 继承 ECSComponent (适合复合数据)
class CompPos extends ECSComponent:
    var x: float = 0.0
    var y: float = 0.0

    func _init(px: float = 0, py: float = 0):
        x = px
        y = py

# 方式 C: 继承 ECSViewComponent (绑定节点)
class CompSprite extends ECSViewComponent:
    # 继承自基类的 .view 属性将存储 Node 引用
    pass
```

#### 2.3 创建实体 (Entities)

实体只是一个 ID，它是挂载组件的载体。

```gdscript
# 在 Main.gd 的 _ready 中

# 创建一个实体
var entity = _world.create_entity()

# 添加组件
entity.add_component("Health", CompHealth.new(100))
entity.add_component("Position", CompPos.new(10, 20))

# 绑定场景中的 Sprite 节点
var sprite_node = $Sprite2D
entity.add_component("View", CompSprite.new(sprite_node))

print("创建实体 ID:", entity.id())
```

---

### 3. 编写系统 (`ECSSystem`)

在直接模式下，系统继承自 `ECSSystem`。它既可以像传统类一样拥有成员变量（状态），也可以像 ECS 系统一样遍历处理数据。

#### 3.1 创建一个移动系统

这个系统负责读取 `Position` 组件，更新数据，并同步到 `View` 组件（Sprite 节点）。

```gdscript
# systems/sys_movement.gd
extends ECSSystem

# 系统内部状态 (State) - 只有 ECSSystem 允许这样做，ECSParallel 不建议
var _speed: float = 50.0

# [生命周期] 系统进入世界时调用
func _on_enter(world: ECSWorld) -> void:
    print("移动系统启动")

# [生命周期] 每帧调用 (由 world.update(delta) 触发)
func _on_update(delta: float) -> void:
    # 1. 获取所有拥有 Position 和 View 组件的实体
    # 使用 world().multi_view 自动利用缓存
    var views = world().multi_view(["Position", "View"])

    for v in views:
        # 获取组件实例
        var pos = v["Position"] as CompPos
        var sprite = v["View"] as CompSprite

        # 逻辑：简单向右移动
        pos.x += _speed * delta

        # 同步：更新 Godot 节点位置
        if is_instance_valid(sprite.view):
            sprite.view.position = Vector2(pos.x, pos.y)

# [生命周期] 系统退出/销毁时调用
func _on_exit(world: ECSWorld) -> void:
    print("移动系统关闭")
```

#### 3.2 注册系统

系统必须注册到 World 中才能运行。

注: 系统的更新顺序 ( _on_update的执行顺序 ) 由系统注册到 World 中的顺序决定。

```gdscript
# Main.gd

func _ready() -> void:
    _world = ECSWorld.new("GameWorld")

    # ... (组件初始化) ...

    # 注册系统
    # 参数1: 系统名称 (用于索引)
    # 参数2: 系统实例
    _world.add_system("MovementSystem", SysMovement.new())
```

---

### 4. 事件驱动编程

`ECSSystem` 能够方便地监听和发送事件，这对于处理游戏逻辑（如“玩家死亡”、“得分”）非常有用。

#### 4.1 发送事件

你可以在任何地方（实体方法中、系统逻辑中）发送事件。

```gdscript
# 在某个造成伤害的逻辑中
func apply_damage(entity_id: int, amount: int):
    # ... 扣血逻辑 ...
    if hp <= 0:
        # 方式 1: 直接通过 World 通知
        _world.notify("entity_died", entity_id)

        # 方式 2: 通过 Entity 包装器通知 (如果持有 Entity 对象)
        # entity.notify("entity_died", entity_id)
```

#### 4.2 在系统中监听事件

利用 `_on_enter` 进行事件绑定，`_on_exit` 进行解绑（虽然框架会在 System 销毁时自动清理，但显式解绑是好习惯）。

```gdscript
# systems/sys_game_manager.gd
extends ECSSystem

func _on_enter(world: ECSWorld) -> void:
    # 监听 "entity_died" 事件
    world.add_callable("entity_died", _on_entity_died)

func _on_exit(world: ECSWorld) -> void:
    world.remove_callable("entity_died", _on_entity_died)

# 事件回调
func _on_entity_died(event: GameEvent) -> void:
    var dead_entity_id = event.data
    print("检测到实体死亡: ", dead_entity_id)

    # 执行游戏逻辑，例如加分或移除实体
    world().remove_entity(dead_entity_id)
```

---

### 第一部分总结：直接模式工作流

1. **创建 World**：`ECSWorld.new()`。
2. **定义 Component**：继承 `ECSComponent` 或 `ECSDataComponent`。
3. **创建 Entity**：`world.create_entity()` 并 `add_component()`。
4. **定义 System**：继承 `ECSSystem`。
   * 重写 `_on_update(delta)` 处理每帧逻辑。
   * 使用 `world().view()` 或 `world().multi_view()` 获取数据。
   * 使用 `_on_enter` 监听事件。
5. **驱动 World**：在 Godot 的 `_process` 中调用 `world.update(delta)`。

这种模式不需要配置复杂的调度器依赖，写起来就像是在写 Godot 的 Manager 类，但底层数据已经完全 ECS 化了。

---

**下一部分：** [2. 通用数据操作](./2.通用数据操作与状态修改.md)
