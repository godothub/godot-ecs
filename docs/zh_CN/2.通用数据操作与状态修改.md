## 2. 通用数据操作与状态修改

无论你使用单线程的 `ECSSystem` 还是多线程的 `ECSParallel`，对数据的**查询**和**修改**都是最核心的操作。

### 1. 查询机制 (Querying)

在系统 `_on_update (ECSSystem)` 或 `thread_function (ECSParallel)` 中，我们需要找到特定的实体集进行处理。框架提供了三种层级的查询方式。

#### 1.1 基础视图 (`view`)

最简单的方式，获取拥有特定单一组件的所有组件实例。

* **适用场景**：只需要处理一种数据，例如统计所有实体的血量。
* **返回值**：组件实例的数组 `Array[ECSComponent]`。

```gdscript
# 获取所有 Health 组件
var healths = world().view("Health")
for hp in healths:
    print(hp.data)
```

#### 1.2 组合视图 (`multi_view`)

获取**同时拥有**指定多个组件的实体。这是 ECS 最常用的操作。

* **适用场景**：移动系统（需要 Position + Velocity），渲染系统（需要 Position + Sprite）。
* **缓存机制**：框架内部使用 `QueryCache`。第一次请求 `["A", "B"]` 时会构建缓存，后续帧调用几乎零开销。增删组件会自动更新缓存。
* **返回值**：字典数组 `Array[Dictionary]`。字典包含 `entity` 引用和请求的组件。

```gdscript
# 获取同时有 Position 和 Velocity 的实体
var results = world().multi_view(["Position", "Velocity"])

for res in results:
    var entity = res["entity"]       # 获取实体引用
    var pos = res["Position"]        # 获取组件实例
    var vel = res["Velocity"]

    # 业务逻辑
    pos.x += vel.x * delta
```

#### 1.3 高级查询器 (`Querier`)

当简单的“与”逻辑（AND）无法满足需求时，可以使用构建者模式的查询器。

* **适用场景**：复杂的过滤逻辑，例如“有 A 但没有 B”，或者“有 A 或 B”。
* **构造**：通过 `world().query()` 获取一个新的查询器实例。

```gdscript
# 查找：有 Health 组件，且没有 Debuff 组件，且血量小于 50 的实体
var dying_entities = world().query() \
    .with(["Health"]) \
    .without(["Debuff"]) \
    .filter(func(data): return data["Health"].data < 50) \
    .exec()

# 注意：Querier 每次 exec 都会动态计算，性能略低于 multi_view 的缓存读取。
# 在高频热路径（Hot Path）中，请优先使用 multi_view。
```

---

### 2. 修改世界状态：直接修改 vs 命令缓冲

在 ECS 中，“修改组件属性”（如 `pos.x += 1`）通常是安全的，但“修改世界结构”（如创建实体、删除组件）则非常敏感。

#### 2.1 为什么有两种修改方式？

| 方式         | **直接修改 (Immediate)**                   | **命令缓冲 (Deferred Commands)**                |
|:---------- |:-------------------------------------- |:------------------------------------------- |
| **操作 API** | `world.create_entity()`, `e.destroy()` | `cmds.spawn()`, `cmds.entity(id).destroy()` |
| **生效时间**   | **立即生效**。下一行代码就能查到改动。                  | **延迟生效**。本帧结束后（或手动 flush 时）统一执行。            |
| **线程安全**   | **❌ 不安全**。多线程环境下会导致崩溃或数据竞争。            | **✅ 安全**。每个线程写入独立的 Buffer，最后在主线程合并执行。       |
| **适用场景**   | 单线程系统 (`ECSSystem`)；主线程逻辑；初始化阶段。       | 多线程系统 (`ECSParallel`)；需要避免遍历时修改集合的场景。       |

#### 2.2 场景 A：单线程中的直接修改 (`ECSSystem`)

在 `ECSSystem` 的 `_on_update` 中，因为运行在主线程，你可以直接调用 World 的 API。

**⚠️ 唯一的陷阱：遍历时修改**
即使是单线程，如果你正在遍历一个列表（如 `view` 返回的数组），此时删除实体会导致迭代器失效或逻辑错误。

```gdscript
# [错误示范]
var list = world().view("Health")
for hp in list:
    if hp.data <= 0:
        # 危险！正在遍历 list，却删除了其中的元素，可能导致跳过下一个元素或报错
        hp.entity().destroy() 

# [正确做法 1]：倒序遍历 (GDScript 较繁琐)
# [正确做法 2]：收集要删除的 ID，遍历结束后统一删除
var to_delete = []
for hp in list:
    if hp.data <= 0:
        to_delete.append(hp.entity().id())

for id in to_delete:
    world().remove_entity(id)
```

#### 2.3 场景 B：多线程中的命令缓冲 (`ECSParallel`)

当我们在下一章介绍的 `ECSParallel` 中工作时，系统可能跑在后台线程。此时**严禁**直接调用 `world.create_entity()` 或 `add_component()`。

框架提供了 `Commands` 来解决这个问题。

**注意：** `Commands` 是一个内部类引用。在 `ECSParallel` 的回调方法中，框架会把这个对象传给你。

**API 使用示例：**

```gdscript
# 假设这是 ECSParallel._view_components 方法内部
# cmds 是框架传入的 Commands 实例

# 1. 销毁实体
cmds.entity(entity_id).destroy()

# 2. 生成新实体并添加组件 (流式 API)
cmds.spawn() \
    .add_component("Health", CompHealth.new(100)) \
    .add_component("Position", CompPos.new(0, 0))

# 3. 为现有实体增删组件
cmds.entity(entity_id) \
    .add_component("Buff", CompBuff.new()) \
    .remove_component("Debuff")

# 4. 发送延迟事件 (同样为了线程安全)
cmds.notify("enemy_spawned", 1)
```

**原理说明：**
所有的操作都会被编码为简单的指令（OpCode）存入数组。当调度器 (`Scheduler`) 完成所有并行任务后，会在主线程统一执行这些指令 (`flush`)。这意味着：

* 你在线程中 `spawn()` 的实体，在本帧的后续系统中是**不可见**的。
* 它们将在下一帧开始前真正出现在 World 中。

---

### 第二部分总结

* **查数据**：
  * 简单用 `view`。
  * 常用组合用 `multi_view`（极速，带缓存）。
  * 复杂筛选用 `query()...exec()`。
* **改数据**：
  * **在 `ECSSystem` (单线程)**：可以直接调用 `world.remove_entity` 等 API，但在遍历过程中要注意集合修改安全。
  * **在 `ECSParallel` (多线程)**：**必须**使用传入的 `cmds` (Commands) 对象进行延迟操作。

---

**下一部分：** [3. 调度模式 (Scheduled Mode)](./3.进阶与并行.md)
