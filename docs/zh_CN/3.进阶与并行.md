## 3. 进阶与并行 (调度模式 / Scheduled Mode)

在简单的游戏中，使用 `ECSSystem` 手动控制更新顺序已经足够。但当你的游戏包含复杂的物理模拟、成百上千的 AI 单位，或者你需要严格控制系统执行顺序（例如：输入 -> 移动 -> 物理 -> 渲染）时，**调度器 (Scheduler)** 模式是最佳选择。

### 1. 为什么需要调度器？

调度器 (`ECSScheduler`) 是一个自动化管线，它解决了三个关键问题：

1. **依赖管理**：自动解析系统间的 `before/after` 关系，构建有向无环图 (DAG)，确保逻辑执行顺序正确。
2. **并发执行**：分析组件的读写权限，自动找出互不冲突的系统，将其放入 `WorkerThreadPool` 并行执行。
3. **命令同步**：自动在帧末（或批次间）合并执行所有系统的 `Commands`，无需手动干预。

### 2. 编写并行系统 (`ECSParallel`)

在调度模式下，我们不再使用 `ECSSystem`，而是继承 `ECSParallel`。

**关键规则：**

* ❌ **无状态**：系统类内部尽量不要存储状态变量（如计时器）。状态应存放在 Singleton 组件或 Resource 中。
* ❌ **无生命周期**：没有 `_on_enter` 或 `_on_exit`。它只关注数据变换。
* ✅ **权限声明**：必须明确告诉框架你要读什么、写什么。

#### 2.1 示例：编写一个简单的生命恢复系统

```gdscript
# systems/sys_regen.gd
extends ECSParallel

func _init():
    # 必须给系统起个名字，用于调度器依赖引用
    super._init("RegenSystem")

# [核心 1] 声明权限
# 告诉调度器：我要读写 "Health" 组件，只读 "RegenRate" 组件
func _list_components() -> Dictionary:
    return {
        "Health": ECSParallel.READ_WRITE, # 可能修改血量
        "RegenRate": ECSParallel.READ_ONLY # 只读取恢复速度
    }

# [核心 2] 开启多线程
# 返回 true 表示这个系统内部可以拆分任务并行处理
func _parallel() -> bool:
    return true 

# [核心 3] 业务逻辑
# 框架会自动遍历符合 _list_components 组合的实体
# 参数 1: view (包含当前实体的组件字典)
# 参数 2: cmds (线程安全的命令缓冲，ECSParallel.Commands 类型)
func _view_components(view: Dictionary, cmds: ECSParallel.Commands) -> void:
    var hp = view["Health"] as CompHealth
    var rate = view["RegenRate"] as CompRegen

    # 简单的数值逻辑
    if hp.data < hp.max_value:
        hp.data += rate.value * delta # 注意：delta 是成员变量，框架自动注入

        # 如果血满了，可以使用 cmds 移除恢复组件（延迟生效）
        if hp.data >= hp.max_value:
            hp.data = hp.max_value
            cmds.entity(view.entity.id()).remove_component("RegenRate")
```

#### 2.2 理解 `_parallel()` 开关

* `return true`: 框架会将匹配到的实体列表切分成多块（Chunks），分发给多个 Worker 线程同时执行 `_view_components`。适合处理大量实体（如 1000+ 个单位）。
* `return false`: 整个系统的逻辑在单一线程中跑完（虽然该系统本身可能与其他系统并行）。适合实体较少或逻辑简单的系统。

---

### 3. 构建与运行调度器

有了系统之后，我们需要把它们组装起来。

#### 3.1 创建调度器

通常在主场景初始化时进行。

```gdscript
# Main.gd
var _scheduler: ECSScheduler

func _ready() -> void:
    _world = ECSWorld.new("GameWorld")
    _scheduler = _world.create_scheduler("MainLoop")

    # 实例化系统
    var sys_input = SysInput.new()
    var sys_move = SysMovement.new()
    var sys_physics = SysPhysics.new()
    var sys_render = SysRender.new()

    # [关键] 定义依赖关系
    # 移动必须在输入之后
    sys_move.after(["InputSystem"])
    # 物理必须在移动之后
    sys_physics.after(["MovementSystem"]) 
    # 渲染必须在物理之后
    sys_render.after(["PhysicsSystem"])

    # 添加到调度器
    _scheduler.add_systems([
        sys_input, 
        sys_move, 
        sys_physics, 
        sys_render
    ])

    # [构建] 解析依赖图，分析读写冲突，生成执行计划
    _scheduler.build()

func _process(delta: float) -> void:
    # 驱动调度器
    _scheduler.run(delta)
```

#### 3.2 冲突检测与自动批处理

假设你有以下两个系统：

1. `SysA`: 写入 `Position`
2. `SysB`: 读取 `Position`

如果没有设置 `.after()` / `.before()` 依赖：

* **传统 ECS**：可能会发生数据竞争，或者结果不确定。
* **本框架**：调度器构建时会发现 `SysA` (Write) 和 `SysB` (Read) 对 `Position` 组件有**资源冲突**。它会自动将它们放在不同的执行批次（Batch）中串行执行，确保安全。

假设你有：

1. `SysMove`: 写入 `Position`

2. `SysDamage`: 写入 `Health` (与 Position 无关)
* **本框架**：调度器发现两者无资源冲突，会将它们安排在同一个批次，利用两个 CPU 核心**同时执行**。

---

### 4. 高级调度技巧

#### 4.1 系统分组 (`in_set`)

你可以给系统分配一个整数 Group ID。调度器在拓扑排序时，会倾向于让 Group ID 小的系统先执行（在满足依赖的前提下）。这有助于逻辑分层。

```gdscript
enum { PHASE_INPUT, PHASE_GAMEPLAY, PHASE_RENDER }

sys_input.in_set(PHASE_INPUT)
sys_move.in_set(PHASE_GAMEPLAY)
```

#### 4.2 动态开关系统

调度器构建后是一个静态的执行图。如果需要暂时禁用某个系统，目前最简单的方法是在系统内部加判断，或者不调用 `scheduler.run()`。
*注意：`ECSWorld.set_system_update` 仅对 `ECSSystem` 有效，对调度器管线内的 `ECSParallel` 无效。*

---

### 第三部分总结

调度模式是通往高性能开发的钥匙：

1. **定义系统**：继承 `ECSParallel`，明确 `_list_components` 读写权限。
2. **处理逻辑**：在 `_view_components` 中编写逻辑，使用 `cmds` 修改结构。
3. **配置依赖**：使用 `.after()`, `.before()` 编织逻辑网。
4. **构建运行**：`scheduler.build()` -> `scheduler.run()`。

通过这种方式，你可以放心地扩展游戏规模，而不必担心复杂的更新顺序维护或多线程崩溃问题。

---

**下一部分：** [生态系统 (Ecosystem)](./4.生态系统(序列化、调试与测试).md)
