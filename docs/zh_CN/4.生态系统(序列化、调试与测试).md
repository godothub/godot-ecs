## 4. 生态系统 (序列化、调试与测试)

### 1. 序列化系统 (Serialization)

Godot 原生的 `var_to_bytes` 可以保存简单数据，但对于包含复杂类实例、循环引用的 ECS 世界来说并不够用。本框架提供了一套基于**归档 (Archive)** 和 **UID 映射** 的序列化方案，支持数据版本升级。

#### 1.1 让组件支持序列化

要让一个组件可以被保存，你需要重写基类 `ECSComponent` 的 `_on_pack`（打包）和 `_on_unpack`（解包）方法。

*(注意：`ECSDataComponent` 默认已经实现了对其 `data` 属性的序列化，无需额外代码)*

```gdscript
# components.gd
class CompPlayerStats extends ECSComponent:
    var level: int = 1
    var exp: int = 0

    # 写入存档
    func _on_pack(ar: Archive) -> void:
        ar.set_var("level", level)
        ar.set_var("exp", exp)

    # 读取存档
    func _on_unpack(ar: Archive) -> void:
        level = ar.get_var("level", 1) # 第二个参数是默认值
        exp = ar.get_var("exp", 0)
```

#### 1.2 数据版本控制与迁移 (Data Upgrading)

当游戏更新时，你可能会修改组件结构（比如把 `exp` 变成了浮点数，或者加了新属性）。直接读取老存档可能会崩溃。框架支持平滑迁移。

```gdscript
class CompPlayerStats extends ECSComponent:
    var level: int = 1
    var exp: float = 0.0 # [新版本变更] exp 变成了浮点数
    var title: String = "Novice" # [新版本变更] 新增了称号

    # 定义当前组件的最新版本号
    func _init():
        pass

    func _on_pack(ar: Archive) -> void:
        ar.version = 2 # 标记当前数据为版本 2
        ar.set_var("level", level)
        ar.set_var("exp", exp)
        ar.set_var("title", title)

    func _on_unpack(ar: Archive) -> void:
        # 这个方法只处理最新版本 (v2) 的读取
        level = ar.get_var("level", 1)
        exp = ar.get_var("exp", 0.0)
        title = ar.get_var("title", "Novice")

    # [关键] 数据转换逻辑：负责把老版本数据补全/转换为新版本
    func _on_convert(ar: Archive) -> void:
        match ar.version:
            0:
                # v0 升 v1: 假设 v1 引入了浮点数经验
                var old_exp = ar.get_var("exp", 0)
                ar.set_var("exp", float(old_exp))
            1:
                # v1 升 v2: v2 新增了称号
                ar.set_var("title", "Novice")
        # 框架会自动将 ar.version + 1，并循环调用此方法直到达到最新版本
```

#### 1.3 注册对象工厂 (`ObjectFactory`)

因为组件是 Godot 的脚本对象，反序列化时需要知道“哪个数据对应哪个类”。我们需要向 `ObjectFactory` 注册它们。这对于内部类（Inner Classes）尤为重要。

```gdscript
var factory = ObjectFactory.new()

# 注册组件类
factory.register(CompPlayerStats)
factory.register(CompHealth, [0]) # 如果构造函数有必填参数，在这里提供默认值

# 如果是全局类 (global class)，通常不需要手动注册，框架会利用 UID 自动查找
```

#### 1.4 保存与加载世界 (`ECSWorldPacker`)

一切就绪后，使用 `ECSWorldPacker` 一键保存整个 ECS 世界。

```gdscript
# 保存逻辑
func save_game(file_path: String) -> void:
    var packer = ECSWorldPacker.new(_world).with_factory(factory)
    var pack_data = packer.pack() # 返回 DataPack 对象

    # 将 DataPack 转换为字节流并存文件
    var stream = ByteStream.new()
    stream.encode_var(pack_data.data())
    stream.write(file_path)

# 加载逻辑
func load_game(file_path: String) -> void:
    var stream = ByteStream.open(file_path)
    if stream:
        var raw_data = stream.decode_var()
        var pack_data = DataPack.new(raw_data)

        # 这里创建世界打包器, 同时设置自定义的对象工厂 (Factory)
        var packer = ECSWorldPacker.new(_world).with_factory(factory)

        # unpack 会自动清空当前世界并恢复存档状态
        if packer.unpack(pack_data):
            print("读取存档成功！")
```

**⚠️ 特殊说明：视图组件的序列化**
`ECSViewComponent` 中存储的是 Godot 场景节点引用。**节点引用无法序列化**。
通常的做法是：

1. 不保存 ViewComponent。
2. 读取存档后，触发一个“实体加载完毕”事件，由某个系统去生成 Godot 节点，并重新把节点绑定到恢复后的实体上。

---

### 2. 调试与测试 (Debugging)

ECS 的缺点之一是数据都在代码池子里，很难像 Godot 场景树那样直观地查看。框架提供了以下工具：

#### 2.1 开启调试打印

在世界初始化时开启，可以在 Godot 控制台看到每个实体的创建、组件的增删以及事件的触发日志。

```gdscript
_world = ECSWorld.new("GameWorld")
_world.debug_print = true # 打印详细日志
```

#### 2.2 使用调试实体 (`DebugEntity`)

如果你在 Godot 调试器的检查器 (Inspector) 中查看 `ECSEntity`，默认是看不到它挂了什么组件的（因为组件存在 World 的池子里）。

开启 `debug_entity` 后，实体会使用 `DebugEntity` 类，它内部维护了一个 `_components` 字典，方便在断点时查看实体内部数据。

```gdscript
_world.debug_entity = true # 创建的所有实体将变成 DebugEntity 实例
```

#### 2.3 测试套件 (`ECSTestSuite`)

框架内置了 `test_suite.gd`。如果你修改了框架源码，或者怀疑框架行为不符合预期，可以运行它。
同时，**该文件是最好的 API 活教材**，展示了 CRUD、复杂 Query、调度器和序列化的最标准用法。

```gdscript
# 在空场景中运行测试
var test = ECSTestSuite.new()
test.run()
```

---

### 第四部分总结

你已经掌握了利用该框架构建完整游戏所需的所有高级功能：

* 使用 `Archive` 灵活地序列化组件数据。
* 利用 `_on_convert` 解决版本迭代带来的存档兼容问题。
* 使用 `ECSWorldPacker` 对世界进行快照备份。
* 利用调试工具追踪 ECS 的黑盒状态。

---

**下一部分：** [API 参考手册](./5.API参考手(简略).md)


